<?php

/*
+----------------------------------------------------------------------+
|This program is free software; you can redistribute it and/or modify  |
|it under the terms of the GNU General Public License as published by  |
|the Free Software Foundation; either version 2 of the License, or     |
|(at your option) any later version.                                   |
|                                                                      |
|This program is distributed in the hope that it will be useful,       |
|but WITHOUT ANY WARRANTY; without even the implied warranty of        |
|MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the          |
|GNU General Public License for more details.                          |
|                                                                      |
|You should have received a copy of the GNU General Public License     |
|along with this program; if not, write to the Free Software           |
|Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.             |
+----------------------------------------------------------------------+
|Authors: Markus Nix <mnix@docuverse.de>                               |
+----------------------------------------------------------------------+
*/


using( 'io.FileUtil' );


/**
 * A class to manage httpd group files used for Basic Authentication.
 *
 * @package org_apache
 */
 
class HTGroup extends PEAR
{
	/**
	 * filename holder
	 * @access public
	 */
	var $file = "";
	
	/**
	 * Is the file empty?
	 * @access public
	 */
	var $empty = false;
	
	/**
	 * raw htpasswd contents
	 * @access public
	 */
	var $contents = "";
	
	/**
	 * Boolean. True if $file exists
	 * @access public
	 */
	var $exists = false;
	
	/**
	 * Boolean. True if $file passes all tests
	 * @access public
	 */
	var $sane = false;
	
	/**
	 * array of [index#][(user|pass)]=value
	 * @access public
	 */
	var $groups = array();

	/**
	 * counter - total number of users in $file
	 * Zero based indexing on $groups
	 * @access public
	 */
	var $groupcount = 0;

	
	/**
	 * Constructor
	 *
	 * @access public
	 */
	function HTGroup( $groupFile = "" )
	{
		if ( !empty( $groupFile ) )
			$this->initialize( $groupFile );
	}

	
	/**
	 * @access public
	 */
	function initialize( $groupFile )
	{
		$this->file	= $groupFile;
		
		// seed the random number gen
		srand( (double)microtime() * 1000000 );

		if ( empty( $groupFile ) )
		{
			// PHP is going to bitch about this, this is here just because.
			return PEAR::raiseError( "Invalid initialize() or new() method: No file specified." );
		}

		if ( file_exists( $this->file ) )
		{
			$this->exists = true;
			
			if ( !PEAR::isError( FileUtil::isSane( $this->file ) ) )
			{
				$this->sane = true;
				$this->htReadFile();
			}
			else
			{
				// preserve the error generated by sane()
				return;
			}
		}
		else
		{
			// non-existant files are safe
			$this->sane = true;
		}
		
		return;
	}

	/**
	 * @access public
	 */
	function sane( $filename )
	{
		// Some kind of *nix machine - let's do some
		// rudimentary checks
		if ( !( is_readable( $filename ) ) )
			return PEAR::raiseError( "File is not readable." );
		
		if ( !( is_writeable( $filename ) ) )
			return PEAR::raiseError( "File is not writeable." );
		
		if ( is_dir( $filename ) )
			return PEAR::raiseError( "File is a directory." );
		
		if ( is_link( $filename ) )
			return PEAR::raiseError( "File is a symlink." );
		
		return true;
	}

	/**
	 * @access public
	 */
	function htReadFile()
	{
		$Mytemp		= array();
		$Myjunk 	= array();
		$count		= 0;
		$empty		= false;
		$contents 	= "";

		$filename 	= $this->file;
		$filesize 	= filesize( $filename );

		if ( $filesize < 3 )
			$empty = true;

		if ( !( $empty ) )
		{
			$this->empty = false;
			$fd = fopen( $filename, "r" );

			if ( empty( $fd ) )
				return PEAR::raiseError( "Fatal file access error." );

			$contents = fread( $fd, filesize( $filename ) );
			fclose( $fd );

			$this->contents = $contents;
			$Mytemp	= split( "\n", $contents );
			
			for ( $count = 0; $count < count( $Mytemp ); $count++ )
			{
				$group = "";
				$user  = "";

				if ( empty( $Mytemp[$count] ) )
					break;
					
				if ( ereg( "^(\n|\W)(.?)", $Mytemp[$count] ) )
					break;

				if ( !( ereg( ":", $Mytemp[$count] ) ) )
				{
					$group = $Mytemp[$count];
					$errno = ( $count + 1 );
					
					return PEAR::raiseError( "Invalid Group." );
				}

				list( $group, $users ) = split( ":", $Mytemp[$count] );

				if ( $group != "" )
				{
					$users  = ereg_replace( "^([ 	]+)", "", $users );
					$UArray = explode( " ", $users );
					$Myjunk[$group] = $UArray;
				}
			}

			$this->groups		= $Myjunk;
			$this->groupcount	= $count;
		}
		else
		{
			// Empty file. Label it as such
			$this->groups		= $Myjunk;
			$this->groupcount	= -1;
			$this->empty		= true;
		}

		return;
	}

	/**
	 * @access public
	 */
	function isGroup( $GroupID )
	{
		if ( empty( $GroupID ) )
			return false;

		$match  = false;
		$MyTemp = $this->groups;

		while ( list( $group, $users ) = each( $MyTemp ) )
		{
			if ( $GroupID == $group )
				$match = true;
		}

		return $match;
	}

	/**
	 * @access public
	 */
	function getGroupNum( $GroupID )
	{
		$groupNum = -1;
		$count = 0;

		if ( empty( $GroupID ) )
			return $groupNum;

		if ( !$this->isGroup( $GroupID ) )
			return PEAR::raiseError( "Group does not exist." );

		$MyTemp = $this->groups;
		while ( list( $group, $users ) = each( $MyTemp ) )
		{
			if ( $GroupID == $group )
				$groupNum = $count;
				
			$count++;
		}

		return $groupNum;
	}

	/**
	 * @access public
	 */
	function renameGroup( $GroupID, $NewID )
	{
		if ( empty( $GroupID ) )
			return false;
			
		if ( empty( $NewID ) )
			return false;

		$match = false;
		
		if ( !$this->isGroup( $GroupID ) )
			return PEAR::raiseError( "Cannot rename non-existant group." );
		
		if ( $this->isGroup( $NewID ) )
			return PEAR::raiseError( "New group already exists." );
		
		$MyTemp = $this->groups;
		$MyTemp[$NewID] = $MyTemp[$GroupID];
		unset( $MyTemp[$GroupID] );
		$this->groups = $MyTemp;
		$this->htWriteFile();

		return true;
	}

	/**
	 * @access public
	 */
	function addGroup( $GroupID, $Users = "" )
	{
		if ( empty( $GroupID ) )
			return false;
			
		if ( !empty( $Users ) )
		{
			if ( ( gettype( $Users ) ) != "array" )
				return PEAR::raiseError( "Invalid data type, expected array." );
		}
		else
		{
			$Users = array();
		}

		if ( $this->isGroup( $GroupID ) )
			return PEAR::raiseError( "Group already exists." );
		
		$MyTemp = $this->groups;
		$MyTemp[$GroupID] = $Users;
		$this->groups = $MyTemp;
		$this->htWriteFile();
		
		return true;
	}

	/**
	 * @access public
	 */
	function isUserInGroup( $UserID, $GroupID )
	{
		if ( empty( $UserID ) )
			return false;
			
		if ( $this->empty )
			return false;
			
		if ( !$this->isGroup( $GroupID ) )
			return false;

		$Group = $this->groups[$GroupID];
		
		if ( empty( $Group ) )
			return false;

		while ( list( $key, $user ) = each( $Group ) )
		{
			if ( $UserID == $user )
				$found = true;
		}

		return $found;
    }

	/**
	 * @access public
	 */
	function getGroups()
	{
		$Groups = array();
		
		if ( $this->empty )
			return false;

		$MyTemp = $this->groups;

		while ( list( $GroupID, $users ) = each( $MyTemp ) )
			$Groups[$GroupID] = $GroupID;

		return $Groups;
	}

	/**
	 * @access public
	 */
	function getUsers()
	{
		$Groups = array();
		$Users  = array();
		$Return = array();

		$MyTemp = $this->groups;
		
		while ( list( $GroupID, $users ) = each( $MyTemp ) )
		{
			while ( list( $key, $UserName ) = each( $users ) )
			{
				if ( !$Return[$UserName])
					$Return[$UserName] = $UserName;
			}
		}

		return $Return;
	}

	/**
	 * @access public
	 */
	function getGroupsForUser( $UserID )
	{
		$Groups = array();
		$count  = 0;
		$found  = true;

		if ( empty( $UserID ) )
			return false;
			
		$MyTemp = $this->groups;

		while ( list( $GroupID, $users ) = each( $MyTemp ) )
		{
			if ( $this->isUserInGroup( $UserID, $GroupID ) )
			{
				$found = true;
				$Groups[$count] = $GroupID;
			}
			
			$count++;
		}
		
		if ( !$found )
			unset( $Groups );

		return $Groups;
    }

	/**
	 * @access public
	 */
	function getUsersForGroup( $GroupID )
	{
		$Users = array();
		$count = 0;
		$found = true;

		if ( empty( $GroupID ) )
		{
			unset($Users);
			return $Users;
		}

		$MyTemp = $this->groups;

		while ( list( $GroupName, $users ) = each( $MyTemp ) )
		{
			if ( $GroupID == $GroupName )
			{
				$found = true;
				$Users = $users;
			}
		}
		
		if ( !$found )
			unset( $Users );

		return $Users;
    }

	/**
	 * @access public
	 */
	function addUser( $UserID, $GroupID )
	{
		$Groups = $this->groups;
		$Users  = $Groups[$GroupID];
		$count  = count($Users);
		
		$Users[$count]    = $UserID;
		$Groups[$GroupID] = $Users;
		$this->groups     = $Groups; 
	}

	/**
	 * @access public
	 */
	function addUserToGroup( $UserID, $GroupID )
	{
		if ( empty( $UserID ) )
			return PEAR::raiseError( "Cannot add empty userid." );
		
		if ( empty( $GroupID ) )
			return PEAR::raiseError( "Cannot add user without group." );

		if ( !$this->isGroup( $GroupID ) )
		{
			$this->addGroup( $GroupID, $UserID );
			return true;
		}
		
		if ( ( gettype( $UserID ) ) != "array" )
		{
			// add one user to the array
			if ( $this->isUserInGroup( $UserID, $GroupID ) )
				return PEAR::raiseError( "User is already a member of another group." );
			else
				$this->addUser( $UserID, $GroupID );
		}
		else
		{
			// add multiple users to the array
			while ( list( $key, $UserName ) = each( $UserID ) )
			{
				if ( $this->isUserInGroup( $UserName, $GroupID ) )
					return PEAR::raiseError( "User is already a member of another group." );
				else
					$this->addUser( $UserName, $GroupID );
			}
		}

		$this->htWriteFile();
		return true;
	}

	/**
	 * @access public
	 */
	function deleteUser( $UserID, $GroupID )
	{
		$Group = $this->groups[$GroupID];
		
		if ( empty( $Group ) )
			return PEAR::raiseError( "Group does not exist." );
		
		while ( list( $key, $user ) = each( $Group ) )
		{
			if ( $user == $UserID )
			{
				unset( $this->groups[$GroupID][$key] );
				return true;
			}
		}
	}

	/**
	 * @access public
	 */
	function deleteUserFromGroup( $UserID, $GroupID )
	{
		$removed = false;

		if ( empty( $UserID ) )
			return false;
			
		if ( $this->empty )
			return false;
			
		if ( ( gettype( $UserID ) ) == "array" )
		{
			//	delete multiple users from array
			while ( list( $key, $UserName ) = each( $UserID ) )
			{
				if ( $this->isUserInGroup( $UserName, $GroupID ) )
				{
					if ( !$this->deleteUser( $UserName, $GroupID ) )
						return false;
				}
				else
				{
					return PEAR::raiseError( "Skipping. User not found in specified group." );
				}
			}
		}
		else
		{
			//	delete one user from the array
			if ( !$this->isUserInGroup( $UserID, $GroupID ) )
				return PEAR::raiseError( "User is not a member of the specified group." );
			else
				$this->deleteUser( $UserID, $GroupID );
		}

		$this->htWriteFile();
		return true;
	}

	/**
	 * @access public
	 */
	function deleteGroup( $GroupID )
	{
		$removed = false;

		if ( empty( $GroupID ) )
			return false;
			
		if ( $this->empty )
			return false;

		$Group = $this->groups[$GroupID];

		if ( empty( $Group ) )
			return PEAR::raiseError( "Group does not exist." );
		
		unset( $this->groups[$GroupID] );
		$removed = true;
		$this->htWriteFile();

		return $removed;
	}

	/**
	 * @access public
	 */
	function htWriteFile()
	{
		$filename = $this->file;
		$tempfile = tempnam( ap_ini_get( "path_tmp_os", "path" ), "fort" );

		if ( !copy( $filename, $tempfile ) )
			return PEAR::raiseError( "Cannot create backup file." );
		
		$fd = fopen( $tempfile, "w" );

		if ( empty( $fd ) )
		{
			unlink( $tempfile );
			return PEAR::raiseError( "Fatal file access error." );
		}

		$MyTemp = $this->groups;

		while ( list( $GroupName, $UserNames ) = each( $MyTemp ) )
		{
			if ( !empty( $GroupName ) )
			{
				fwrite( $fd, "$GroupName:" );
				
				if ( ( gettype( $UserNames ) ) != "array" )
				{
					$UserNames = ereg_replace( "([ 	]+)", "", $UserNames );
					
					if ( !empty( $UserNames ) )
						fwrite( $fd, " $UserNames" );
				}
				else
				{
					while ( list( $key, $User ) = each( $UserNames ) )
					{
						$User = ereg_replace( "([ 	]+)", "", $User );
						
						if ( !empty( $User ) )
							fwrite( $fd, " $User" );
					}
				}
				
				fwrite( $fd, "\n" );
			}
		}

		fclose( $fd );

		if ( !copy( $tempfile, $filename ) )
		{
			unlink( $tempfile );
			return PEAR::raiseError( "Cannot copy file." );
		}

		unlink( $tempfile );
		
		if ( file_exists( $tempfile ) )
		{
			// not fatal but it should be noted
			return PEAR::raiseError( "Cannot unlink file." );
		}

		$this->contents = "";
		$this->groups   = "";
		
		$this->initialize( $filename );
		return true;
	}
} // END OF HTGroup

?>
