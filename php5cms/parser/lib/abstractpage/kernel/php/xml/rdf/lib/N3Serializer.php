<?php

/*
+----------------------------------------------------------------------+
|This program is free software; you can redistribute it and/or modify  |
|it under the terms of the GNU General Public License as published by  |
|the Free Software Foundation; either version 2 of the License, or     |
|(at your option) any later version.                                   |
|                                                                      |
|This program is distributed in the hope that it will be useful,       |
|but WITHOUT ANY WARRANTY; without even the implied warranty of        |
|MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the          |
|GNU General Public License for more details.                          |
|                                                                      |
|You should have received a copy of the GNU General Public License     |
|along with this program; if not, write to the Free Software           |
|Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.             |
+----------------------------------------------------------------------+
|Authors: Gunnar AA. Grimnes <ggrimnes@csd.abdn.ac.uk>                 |
|         Markus Nix <mnix@docuverse.de>                               |
+----------------------------------------------------------------------+
*/


define( "N3SERIALIZER_MAGIC_STRING", "~~~" );


/**
 * PHP Notation3 Serializer (Experimental)
 * 
 * This serialises models to N3 Syntax
 * 
 * Supported N3 features: 
 * <ul>
 *   <li>Using [ ] for blank nodes, or _: if nescessary</li>
 * </ul>
 * 
 * Un-supported N3 Features include: 
 * <ul>
 *   <li>Reification</li>
 * </ul>
 *
 * TODO: * added namespace prefixes are persisent...
 *
 * @package xml_rdf_lib
 */
 
class N3Serializer extends PEAR
{
	/**
	 * @access public
	 */
  	var $prefixes;
	
	/**
	 * keeps track of already serialized resources
	 * @access public
	 */
  	var $done;
	
	/**
	 * @access public
	 */
  	var $resourcetext; 
	
	/**
	 * @access public
	 */
  	var $resourcetext_taken; 
	
	/**
	 * @access public
	 */
  	var $model;
	
	/**
	 * @access public
	 */
  	var $res; 
	
	/**
	 * @access public
	 */
  	var $anon;
	
	
  	/** 
   	 * Adds a new namespace prefix to use. 
   	 * Unknown namespaces will become ns0, ns1 etc.
	 *
   	 * @access public
   	 * @param string $s
   	 * @return void 
   	 */
  	function addNSPrefix( $ns, $prefix ) 
	{ 
    	$this->prefixes[$ns] = $prefix; 
  	}

  	/**
   	 * Serializes a model to N3 syntax.
   	 *
   	 * @param     object Model $model
   	 * @return    string
   	 * @access    public
   	 */
  	function &serialize( &$m )
	{ 
    	$this->reset();
		
    	$this->model = $m;
    	$this->res   = "";
      
    	$namespaces  = array();
    	$count       = array();
    	$resources   = array(); 
    	
		foreach ( $m->triples as $t )
		{ 
      		$s = $t->getSubject();
      		
			if ( is_a( $s, "Resource" ) ) 
				$namespaces[$s->getNamespace()] = 1;

      		$p = $t->getPredicate();
      		
			if ( is_a( $p, "Resource" ) ) 
				$namespaces[$p->getNamespace()] = 1;

      		$o = $t->getObject();
      		
			if ( is_a( $o, "Resource" ) ) 
				$namespaces[$o->getNamespace()] = 1;
      
      		$uri = $s->getURI();
      
      		if ( isset( $count[$uri] ) )
			{ 
				$count[$uri]++;
      		} 
			else
			{ 	
				$count[$uri] = 0;
				$resources[$uri] = $s;
      		}
    	}

    	$this->res .= "# Generated by N3Serializer from Abstractpage.\n";

    	$this->doNamespaces( $namespaces ); 

    	$this->res .= "\n\n";

    	arsort( $count );
    
    	foreach ( $count as $k => $v )
		{ 
      		$this->doResource( $resources[$k] ); 
      		// $this->res .= ".\n";
    	}

    	$c = 0;
    	foreach ( $this->resourcetext as $r => $t )
		{ 
      		if ( preg_match_all( "/" . N3SERIALIZER_MAGIC_STRING . "([^ ]+)" . N3SERIALIZER_MAGIC_STRING . "/", $t, $ms, PREG_SET_ORDER ) )
			{
				foreach ( $ms as $m )
				{ 
	  				$rp = $this->resourcetext[$m[1]];
	  				$t  = preg_replace( "/" . N3SERIALIZER_MAGIC_STRING . $m[1] . N3SERIALIZER_MAGIC_STRING . "/", $rp, $t );
				}
      		}
      	
			if ( !( isset( $this->resourcetext_taken[$r] ) && $this->resourcetext_taken[$r] > 0 ) ) 
				$this->res .= $t . ".\n"; 
      	
			$c++;
  		}

    	return $this->res;
  	}

	/**
	 * Serializes a model and saves it into a file.
	 * Returns false if the model couldn't be saved to the file.
	 *
	 * @access	public
	 * @param     object RdfMemoryModel $model
	 * @param     string $filename
	 * @return    boolean
	 * @access    public
	 */
 	function saveAs( &$model, $filename )
	{
   		// serialize model
   		$n3 = $this->serialize( $model );

   		// write serialized model to file
   		$file_handle = @fopen( $filename, 'w' );
   	
		if ( $file_handle )
		{
      		fwrite( $file_handle, $n3 );
      		fclose( $file_handle );
      		
			return true;
   		}
		else
		{
      		return false;
   		}
 	}
  

	// private methods

	/**
	 * @access private
	 * @param void
	 * @return void 
	 */
  	function reset()
	{
    	$this->anon = 0;
    	$this->done = array();
    	$this->resourcetext_taken = array();
    	$this->resourcetext = array();
    	$this->res = "";
    	$this->model = null;

    	$this->prefixes["http://www.w3.org/1999/02/22-rdf-syntax-ns#"] = "rdf";
    	$this->prefixes["http://www.w3.org/2000/01/rdf-schema#"] = "rdfs";
    	$this->prefixes["http://www.w3.org/2002/07/owl#"] = "owl";
    	$this->prefixes["http://xmlns.com/foaf/0.1/"] = "foaf";
    	$this->prefixes["http://purl.org/dc/elements/1.1/"] = "dc";
    	$this->prefixes["http://www.w3.org/2000/10/XMLSchema#"] = "xmls";
    	$this->prefixes["http://www.w3.org/2000/10/swap/pim/contact#"] = "contact";
  	}

	/**
	 * Makes ns0, ns1 etc. prefixes for unknown prefixes. 
	 * Outputs @prefix lines.
	 *
	 * @access private
	 * @param array $n
	 * @return void 
	 */
  	function doNamespaces( &$n )
	{ 
    	$c = 0;
    	foreach ( $n as $ns => $nonsense )
		{ 
      		if ( !$ns ) 
				continue;  
      		
			if ( isset( $this->prefixes[$ns] ) )
			{
				$p = $this->prefixes[$ns];
      		}
			else
			{ 
				$p = "ns" . $c;
				$this->prefixes[$ns] = $p;
				$c++;
      		}
      		
			$this->res .= "@prefix $p: <" . $ns . ">.\n";
    	}
  	}

	/**
	 * Fill in $resourcetext for a single resource. 
	 * Will recurse into Objects of triples, but should never look ? (really?)
	 *
	 * @access private
	 * @param object Resource $r
	 * @return boolean
 	 */
  	function doResource( &$r )
	{ 
    	// print $r->getURI(); 

    	$ts = $this->model->find( $r, null, null );
    	
		if ( count( $ts->triples ) == 0 )
			return; 

    	$out = "";

    	if ( isset( $this->done[$r->getURI()] ) && $this->done[$r->getURI()] )
		{
      		if ( is_a( $r, "BlankNode" ) )
			{ 
				if ( $this->resourcetext_taken[$r->getURI()] == 1 )
				{ 
	  				// Oh bother, we must use the _:blah construct. 
	  				$a = $this->resourcetext[$r->getURI()];
	  				$this->resourcetext[$r->getURI()] = "_:anon" . $this->anon;
	  
	  				$this->resourcetext["_:anon" . $this->anon] = $this->fixAnon( $a, "_:anon" . $this->anon );
	  				$this->resourcetext_taken[$r->getURI()] = 2; 
	  				$this->anon++;
				}
      		}
      		
			return false; 
    	}
    	
		$this->done[$r->getURI()] = true;

    	if ( is_a( $r, "Resource" ) )
		{
      		if ( is_a( $r, "BlankNode" ) )
				$out .= "[ ";
			else
				$this->doURI( $r, $out );
    	}
		else
		{
			return PEAR::raiseError( "Not a resource.", null, PEAR_ERROR_DIE );
    	}

    	usort( $ts->triples, "statementsorter" );
   
   		$lastp  = "";
    	$out   .= " ";

    	foreach ( $ts->triples as $t )
		{ 
      		$p = $t->getPredicate(); 
      
      		if ( $p == $lastp )
			{
				$out .= " , "; 
      		}
			else
			{ 
				if ( $lastp != "" )
					$out .= " ; "; 
				
				$this->doURI( $p, $out );
				$lastp = $p;
      		}

      		$out .= " ";
      		$o = $t->getObject();
      
      		if ( is_a( $o, "Literal" ) )
			{ 
				$l = $o->getLabel();
				
				if ( strpos( $l, "\n" ) === false )
	  				$out .= "\"$l\"";
				else
	  				$out .= "\"\"\"$l\"\"\"";
				
				if ( $o->getDatatype()!="" ) 
	  				$out .= "^^" . $o->getDatatype();
	
				// TODO: Add language
      		} 
      
      		if ( is_a( $o, "Resource" ) )
			{
				if ( is_a( $o, "BlankNode" ) )
				{
	  				$this->doResource( $o );
	  				$out .= N3SERIALIZER_MAGIC_STRING . $o->getURI() . N3SERIALIZER_MAGIC_STRING; // $this->resourcetext[$o->getURI()];
	  				$this->resourcetext_taken[$o->getURI()] = 1;
				}
				else
				{ 
	  				$this->doURI( $o, $out );
				}
      		}
    	}
    
    	if ( is_a( $r, "BlankNode" ) ) 
			$out .= " ] "; 

    	$this->resourcetext[$r->getURI()] = $out; 
    	return true;
  	}

  	/** 
   	 * Format a single URI.
	 *
   	 * @param string $s
   	 * @access private
   	 * @return void
   	 */
  	function doURI( &$r, &$out )
	{ 
    	if ( $r->getURI() == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" )
		{
      		$out .= "a";
      		return; 
    	}
    	
		if ( $r->getNamespace() != "" )
		{
      		$out .= $this->prefixes[$r->getNamespace()] . ":" . $r->getLocalName();
    	}
		else
		{ 
      		// Will this ever happen? 
      		$out .= $r->getURI();
    	}
  	}
  
  	/** 
   	 * Fix the resourcetext for a blanknode where the _: construct was used.
	 *
   	 * @param string $s
   	 * @param string $a
   	 * @access private
   	 * @return void
   	 */
  	function fixAnon( $t, $a )
	{ 
    	$t = preg_replace( "/( \] $|^\[ )/", "", $t ); 
    	return $a . $t;
  	}
} // END OF N3Serializer

?>
