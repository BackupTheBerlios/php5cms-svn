<?php

/*
+----------------------------------------------------------------------+
|This program is free software; you can redistribute it and/or modify  |
|it under the terms of the GNU General Public License as published by  |
|the Free Software Foundation; either version 2 of the License, or     |
|(at your option) any later version.                                   |
|                                                                      |
|This program is distributed in the hope that it will be useful,       |
|but WITHOUT ANY WARRANTY; without even the implied warranty of        |
|MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the          |
|GNU General Public License for more details.                          |
|                                                                      |
|You should have received a copy of the GNU General Public License     |
|along with this program; if not, write to the Free Software           |
|Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.             |
+----------------------------------------------------------------------+
|Authors: Markus Nix <mnix@docuverse.de>                               |
+----------------------------------------------------------------------+
*/


/**
 * ResultCache is a class used to cache result of your script(function).
 * On first execution of function, execute the function and write returned  
 * data to file(cache), on second execution and more, read data from file.
 *
 * Example:
 *
 * $sql = "your complex query";
 * function yourFunc( $sql ) 
 * {
 *     $result = mysql_query( $sql ) or die ( db_error() );
 *     while( $row = mysql_fetch_row( $result ) )
 *         $array[] = $row;
 *     
 *     return $array;
 * }
 * 
 * $cache = new ResultCache();
 * $cache->setSerialize( true );
 * $data = $cache->getData( 'cache_id', 'yourFunc', $sql );
 *
 * @package util
 */

class ResultCache extends PEAR
{
	/**
	 * directory where cache stored
	 * @access public
	 */
	var $cache_dir = '';
	
	/**
	 * file extension, in which cache will be saved
	 * @access public
	 */
	var $file_ext = '.txt';
	
	/**
	 * serialize or not data, if returnrd data is array you should serialize it
	 * @access public
	 */
	var $do_serialize = false;
								
	/**
	 * use it for global refresh
	 * @access public
	 */
	var $refresh = false;
	
	
	/**
     * Constructor
     *
	 * @param    string    $cache_dir    (optional) directory where cache files will be
     * @access   public
     */
	function ResultCache( $cache_dir = false ) 
	{
		if ( $cache_dir )
			$this->cache_dir = $cache_dir;
	}

	
	/**
	 * Set behavior for reading and wring cache.
	 *
	 * If true data will be serialized before writing cache and unserialized after reading cache
	 * Can be used to store resultset from sql query, like array
	 *
	 * @param     boolean   $set true/false
	 * @access    public      
	 */
	function setSerialize( $set = true ) 
	{
		$this->do_serialize = $set;
	}
	
	/**
	 * Get cache or raw data.
	 *
	 * Get data using function - $f_name or from cache if any
	 * if no cache or $refresh = true, write new cache
	 *
	 * @param    string    $cache_id    id for current cache, use md5 if complex string
	 * @param    string    $f_name      function name
	 * @param    mixed     $f_param     string or array, parameters for function	
	 * @param    boolean   $refresh     true if need to refresh data
	 *
	 * @return   string    data generated by function or from cache
	 * @access   public
	 */
	function getData( $cache_id, $f_name, $f_param = false, $refresh = false ) 
	{	
		$cache_id = $this->cache_dir . $cache_id . $this->file_ext;
		$data = $this->read( $cache_id );
		
		if ( $this->refresh || $refresh || !$data ) 
		{
			if ( $f_param ) 
			{
				if ( !is_array( $f_param ) ) 
					$f_param = array( $f_param ); 
				
				$data = call_user_func_array( $f_name, $f_param );
			} 
			else 
			{
				$data = call_user_func( $f_name );
			}
			
			if ( $this->do_serialize )
				$data = serialize( $data );
				
			$this->write( $cache_id, $data );
		}
		
		if ( $this->do_serialize )
			$data = unserialize( $data );
			
		return $data;
	}
	
	/**
	 * Get data from file.
	 *
	 * @param    string/filename    $filename    filename to read
	 *
	 * @return   string     data from file or false on failure
	 * @access   public
	 */
	function read( $filename ) 
	{
		$data = false;
		
		if ( $fp = @fopen( $filename, "rb" ) ) 
		{
			$data = fread( $fp, filesize( $filename ) );
			fclose( $fp );
		}
		
		return $data;
	}

	/**
	 * Write data to file.
	 *
	 * @param    string/filename    $filename    filename to write
	 * @param    string             $data        data to write
	 * 
	 * @return   boolean    true/false
	 * @access   public
	 */
	function write( $filename, $data ) 
	{	
		$ret = false;
		
		if ( $fp = @fopen( $filename, 'ab' ) ) 
		{
			flock( $fp, LOCK_EX );
			ftruncate( $fp, 0 );
			fputs( $fp, $data );
			fflush( $fp );
			flock( $fp, LOCK_UN );
			fclose( $fp );
			
			$ret = true;
		}
		
		return $ret;
	}	
} // END OF ResultCache

?>
