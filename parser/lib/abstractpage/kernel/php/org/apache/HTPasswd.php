<?php

/*
+----------------------------------------------------------------------+
|This program is free software; you can redistribute it and/or modify  |
|it under the terms of the GNU General Public License as published by  |
|the Free Software Foundation; either version 2 of the License, or     |
|(at your option) any later version.                                   |
|                                                                      |
|This program is distributed in the hope that it will be useful,       |
|but WITHOUT ANY WARRANTY; without even the implied warranty of        |
|MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the          |
|GNU General Public License for more details.                          |
|                                                                      |
|You should have received a copy of the GNU General Public License     |
|along with this program; if not, write to the Free Software           |
|Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.             |
+----------------------------------------------------------------------+
|Authors: Markus Nix <mnix@docuverse.de>                               |
+----------------------------------------------------------------------+
*/


using( 'io.FileUtil' );


/**
 * @package org_apache
 */
 
class HTPasswd extends PEAR
{
	/**
	 * filename holder
	 * @access public
	 */
	var $file = "";
	
	/**
	 * Is the file empty?
	 * @access public
	 */
	var $empty = false;
	
	/**
	 * Raw htpasswd contents
	 * @access public
	 */
	var $contents = "";
	
	/**
	 * Boolean. True if $file exists
	 * @access public
	 */
	var $exists = false;
	
	/**
	 * Boolean. True if $file passes all tests
	 * @access public
	 */
	var $sane = false;
	
	/**
	 * Array of [index#][(user|pass)]=value
	 * @access public
	 */
	var $users = array();

	/**
	 * Counter - total number of users in $file
	 * Zero based indexing on $users
	 * @access public
	 */	
	var $usercount = 0;


	/**
	 * Constructor
	 *
	 * @access public
	 */
	function HTPasswd( $passwdFile = "" )
	{
		if ( !empty( $passwdFile ) )
			$this->initialize( $passwdFile );
	}


	/**
	 * The Initialize function sets up the file, checks it
	 * for sanity, then loads it into the processes memory
	 * htReadFile() should only be called using this method.
	 *
	 * @access public
	 */
	function initialize( $passwdFile )
	{
		$this->file	= $passwdFile;
		srand( (double)microtime() * 1000000 ); // seed the random number gen

		if ( empty( $passwdFile ) )
		{
			// PHP is going to bitch about this, this is here just because
			return PEAR::raiseError( "Invalid initialize() or new() method: No file specified." );
		}

		if ( file_exists( $this->file ) )
		{
			$this->exists = true;
			
			if ( !PEAR::isError( FileUtil::isSane( $this->file ) ) )
			{
				$this->sane = true;
				$this->htReadFile();
			}
			else
			{
				// preserve the error generated by sane()
				return;
			}
		}
		else
		{
			// non-existant files are safe
			$this->sane = true;
		}
		
		return;
	}

	/**
	 * Internal function to read the file and process it's contents
	 * Can be called publicly to re-read the file, but why would
	 * you want to introduce another series of system calls like that?
	 * This does the lions share of the work. This should only be
	 * called once per process, and it should be called internally
	 * by the initialize method. Have I mentioned that enough yet?
	 *
	 * @access public
	 */
	function htReadFile()
	{
		$Mytemp		= array();
		$Myjunk 	= array();
		$Junk		= array();
		$count		= 0;
		$user   	= "";
		$pass		= "";
		$temp		= "";
		$key		= "";
		$val		= "";
		$filesize 	= 0;
		$errno		= 0;
		$empty		= false;
		$contents 	= "";

		$filename 	= $this->file;
		$filesize 	= filesize( $filename );

		if ( $filesize < 3 )
			$empty = true;

		// Why did I pick 3? I dunno - seemed like the number
		// to use at the time.
		// (Actually, think [char]:[\n], the absolute smallest
		// size a "legitimate" password file can ever be.)
		if ( !($empty ) )
		{
			$this->empty = false;
			$fd = fopen( $filename, "r" );

			if ( empty( $fd ) )
				return PEAR::raiseError( "Fatal File access error." );

			$contents = fread( $fd, filesize( $filename ) );
			fclose( $fd );
			$this->contents = $contents;
			$Mytemp	= split( "\n", $contents );
			
			for ( $count = 0; $count < count( $Mytemp ); $count++ )
			{
				$user = "";
				$pass = "";

				if ( empty( $Mytemp[$count] ) )
					break;
					
				if ( ereg( "^(\n|\W)(.?)", $Mytemp[$count] ) )
					break;

				if ( !( ereg( ":", $Mytemp[$count] ) ) )
				{
					$user  = $Mytemp[$count];
					$errno = ( $count + 1 );
					
					return PEAR::raiseError( "Invalid user." );
				}

				list( $user, $pass ) = split( ":", $Mytemp[$count] );

				if ( ( $user != "" ) && ( $pass != "" ) )
				{
					$Myjunk[$count]["user"]	= $user;
					$Myjunk[$count]["pass"]	= $pass;
				}
			}

			$this->users     = $Myjunk;
			$this->usercount = $count;

		}
		else
		{
			// Empty file. Label it as such
			$this->users     = $Myjunk;
			$this->usercount = -1;
			$this->empty     = true;
		}

		return;
	}

	/**
	 * Given a plain text password and salt, returns crypt() encrypted
	 * version. If salt is not passed or referenced, it will generate
	 * a random salt automatically.
	 *
	 * @access public
	 */
	function cryptPass( $passwd, $salt = "" )
	{
		if ( !( $passwd ) )
		{
			// Return what we were given
			// If calling this directly, do something like
			// $enc_pass = $Htpasswd->cryptPass($pass);
			// if (empty($enc_pass)) { BARF! }
			// You should really verify the data before calling
			// this though - I do.			
			return "";
		}

		if ( !empty( $salt ) )
		{
			// Make sure only use 2 chars
			$salt = substr( $salt, 0, 2 );
		}
		else
		{
			// If no salt, generate a (pseudo) random one
			$salt = $this->genSalt();
		}

		return ( crypt( $passwd, $salt ) );
	}

	/**
	 * Returns true if UserID is found in the password file. False
	 * otherwise.
	 *
	 * @access public
	 */
	function isUser( $UserID )
	{
		$key   = "";
		$val   = "";
		$user  = "";
		$pass  = "";
		$found = false;

		if ( empty( $UserID ) )
			return false;
			
		if ( $this->empty )
			return false;

		for ( $count = 0; $count <= $this->usercount; $count++ )
		{
			if ( $UserID == $this->users[$count]["user"] )
				$found = true;
        }

		return $found;
    }

	/**
	 * Fetches the encrypted password from the password file and
	 * returns it. Returns null on failure.
	 *
	 * @access public
	 */
	function getPass( $UserID )
	{
		$key     = "";
		$val     = "";
		$user    = "";
		$pass    = "";
		$usernum = -1;

		if ( $this->empty )
			return $pass;
			
		if ( empty( $UserID ) )
			return $pass;
			
		if ( !( $this->isUser( $UserID ) ) ) 
			return $pass;

		$usernum = $this->getUserNum( $UserID );
		
		if ( $usernum == -1 )
			return false;

		$pass = $this->users[$usernum]["pass"];
		return $pass;
    }

	/**
	 * Returns true if Users password matches the password in the password file.
	 * method deprecated 0.5: use verifyUser() instead.
	 *
	 * @access public
	 */
	function checkPass( $UserID, $Pass )
	{
		$retval = $this->verifyUser( $UserID, $Pass );
		return $retval;
    }

	/**
	 * Returns true if Users password is authenticated, false otherwise.
	 * $Pass should be passed in un-encrypted
	 *
	 * @access public
	 */
	function verifyUser( $UserID, $Pass )
	{
		$pass = "";
		$match = false;
		$usernum = -1;
		$salt = "";

		if ( $this->empty )
			return false;
			
		if ( empty( $UserID ) )
			return false;
			
		if ( empty( $Pass ) )
			return false;
			
		if ( !( $this->isUser( $UserID ) ) )
			return false;

		$usernum = $this->getUserNum( $UserID );
		
		if ( $usernum == -1 )
			return false;

		$pass = $this->users[$usernum]["pass"];
		$salt = substr( $pass, 0, 2 );
		$Pass =	$this->cryptPass( $Pass, $salt ); 

		if ( $pass == $Pass )
			$match = true;

		return $match;
    }

	/**
	 * Changes an existing users password. If "oldPass" is null, or 
	 * if oldPass is not passed to this method, there is no checking 
	 * to be sure it matches their old password.
	 * Needless to say, you shouldn't do that, but I'll give you
	 * the rope...
	 * NewPass should be passed to this method un-encrypted.
	 * Returns true on success, false on failure
	 *
	 * @access public
	 */
	function changePass( $UserID, $newPass, $oldPass = "" )
	{
		$newname;
		$newpass;
		
		$passwdFile	= $this->file;
		$pass		= "";

		// Can't very well change the password of a non-existant
		// user now can we?

		if ( $this->empty )
			return false;
			
		if ( empty( $UserID ) )
			return false;

		// no sniffing for valid user IDs please
		if ( !( $this->isUser( $UserID ) ) )
			return PEAR::raiseError( "ChangePass failure: Authentication Failure." );

		if ( empty( $newPass ) )
			return PEAR::raiseError( "ChangePass failure: No new password submitted." );

		$newname = strtolower( $UserID  );
		$newpass = strtolower( $newPass );

		if ( $newname == $newpass )
			return PEAR::raiseError( "ChangePass failure: UserID and password cannot be the same." );

		// If no old Password, don't force it to match
		// their existing password. NOT RECOMMENDED!
		// Be SURE to always send the oldPass!
		if ( !( empty( $oldPass ) ) )
		{
			// must validate the user now
			if ( !( $this->verifyUser( $UserID, $oldPass ) ) )
				return PEAR::raiseError( "RenameUser failure: Authentication Failure." );

			// OK - so the password is valid - are we planning
			// on actually changing it ?

			if ( $newPass == $oldPass )
			{
				// passwords are the same, no sense wasting time here
				return true;
			}
		}

		// Valid user with new password, OK to change.
		$usernum = $this->getUserNum( $UserID );

		if ( $usernum == -1 )
			return false;

		// no salt to cryptPass - generates a random one for us
		$this->users[$usernum]["pass"] = $this->cryptPass( $newPass );

		if ( !( $this->htWriteFile() ) )
			return PEAR::raiseError( "Cannot save password file." );

		return true;
    }

	/**
	 * A modified copy of changePass - changes the users name.
	 * If $Pass is sent, it authenticates before allowing the change.
	 * Returns true on success, false if; 
	 *    The OldID is not found
	 *    The NewID already exists
	 *    The Password is sent and auth fails
	 *
	 * @access public
	 */
	function renameUser( $OldID, $NewID, $Pass = "" )
	{
		if ( $this->empty )
			return false;
			
		if ( empty( $OldID ) )
			return false;
			
		if ( empty( $NewID ) )
			return false;

		if ( !( $this->isUser( $OldID ) ) )
		{
			//	Send an auth failure - prevents people from fishing for
			//	valid userIDs.
			//	YOU will know its's because User is Unknown - 
			//	this error is slightly different than the real
			//	authentication failure message. Compare the two.
			//	Security through obscurity sucks but oh well..

			return PEAR::raiseError( "RenameUser failure: Authentication Failure." );
		}
		
		if ( $this->isUser( $NewID ) )
			return PEAR::raiseError( "Cannot change UserID, ID already exists." );

		// If no Password, force a name change,
		// otherwise authenticate first.
		// Be SURE to always send the Pass!
		if ( !( empty( $Pass ) ) )
		{
			//	Must validate the user now
			if ( !( $this->verifyUser( $OldID, $Pass ) ) )
				return PEAR::raiseError( "RenameUser failure: Authentication Failure." );

			// OK - so the password is valid - are we planning
			// on actually changing our name ?
			if ( $NewID == $OldID )
			{
				// Nice new name ya got there, Homer...
				return true;
			}
		}

		// Valid user, OK to change.
		$usernum = $this->getUserNum( $OldID );

		if ( $usernum == -1 )
			return false;

		$this->users[$usernum]["user"] = $NewID;

		if ( !( $this->htWriteFile() ) )
			return PEAR::raiseError( "Cannot save password file." );

		return true;
    }

	/**
	 * Writes the new password file. Writes a temp file first,
	 * then attempts to copy the temp file over the existing file
	 * Original file not harmed if this fails.
	 * Also kinda sorta gets around the lack of file locking in PHP
	 * On success, re-calls the initialize method to re-read
	 * the new password file and returns true. False on failure
	 *
	 * @access public
	 */
	function htWriteFile()
	{
		$filename = $this->file;
		$tempfile = tempnam( ap_ini_get( "path_tmp_os", "path" ), "fort" );
		$name     = "";
		$pass     = "";
		$count    = 0;
		$fd;
		$myerror = "";

		if ( $this->empty )
			$this->usercount = 0;

		if ( !copy( $filename, $tempfile ) )
			return PEAR::raiseError( "Cannot create backup file." );

		$fd = fopen( $tempfile, "w" );

		if ( empty( $fd ) )
		{
			unlink( $tempfile );
			return PEAR::raiseError( "Fatal File access error." );
		}

		for ( $count = 0; $count <= $this->usercount; $count++ )
		{
			$name = $this->users[$count]["user"];
			$pass = $this->users[$count]["pass"];

			if ( ( $name != "" ) && ( $pass != "" ) )
				fwrite( $fd, "$name:$pass\n" );
		}

		fclose( $fd );

		if ( !copy( $tempfile, $filename ) )
		{
			unlink( $tempfile );
			return PEAR::raiseError( "Cannot copy file." );
		}

		// update successful
		unlink( $tempfile );

		if ( file_exists( $tempfile ) )
		{
			// not fatal but it should be noted
			return PEAR::raiseError( "Cannot unlink file." );
		}

		// Update the information in memory with the
		// new file contents.
		$this->initialize( $filename );
		return true;
	}

	/**
	 * Should be fairly obvious - adds a user to the htpasswd file
	 * Returns true on success, false on failure
	 *
	 * @access public
	 */
	function addUser( $UserID, $newPass )
	{
		$count = $this->usercount;

		if ( empty( $UserID ) )
			return PEAR::raiseError( "AddUser failure. No UserID." );
		
		if ( empty( $newPass ) )
			return PEAR::raiseError( "AddUser failure. No password." );

		if ($this->isUser($UserID))
			return PEAR::raiseError( "AddUser failure. UserID already exists." );

		if ( $this->empty )
			$count = 0;

		$this->users[$count]["user"] = $UserID;

		//	No salt to cryptPass() - will generate a random one for us

		$this->users[$count]["pass"] = $this->cryptPass( $newPass );

		if ( PEAR::isError( $this->htWriteFile() ) )
			return PEAR::raiseError( "Cannot add user due to file error." );

		// successfully added user
		return true;
    }

	/**
	 * Same as addUser, but adds the user to the password file
	 * with a randomly generated password.
	 * Returns plain text password on success, null on failure.
	 *
	 * @access public
	 */
	function assignPass( $UserID )
	{
		$pass  = "";
		$count = $this->usercount;

		if ( empty( $UserID ) )
			return PEAR::raiseError( "AssignPass failure. No UserID." );
		
		if ( $this->empty )
			$count = 0;

		if ( $this->isUser( $UserID ) )
			return PEAR::raiseError( "AssignPass failure. UserID already exists. Use genPass instead." );

		$pass = $this->genPass();

		$this->users[$count]["user"] = $UserID;

		// no salt to cryptPass() - will generate a random one for us
		$this->users[$count]["pass"] = $this->cryptPass( $pass );

		if ( !( $this->htWriteFile() ) )
			return PEAR::raiseError( "Cannot add user due to file error." );

		// successfully added user
		return( $pass );
    }

	/**
	 * Again, fairly obvious - deletes a user from the htpasswd file.
	 * Returns true on success, false on failure.
	 *
	 * @access public
	 */
	function deleteUser( $UserID )
	{
		$found = false;

		// can't delete non-existant UserIDs
		if ( $this->empty )
			return false;
		
		// PHP should complain about this, but just in case
		if ( empty( $UserID ) )
			return PEAR::raiseError( "DeleteUser failure. No UserID to delete." );
		
		if ( !($this->isUser( $UserID ) ) )
			return PEAR::raiseError( "Cannot delete: User not found." );

		$usernum = $this->getUserNum( $UserID );

		if ( $usernum == -1 )
			return false;

		$this->users[$usernum]["user"] = "";
		$this->users[$usernum]["pass"] = "";

		if ( !( $this->htWriteFile() ) )
			return PEAR::raiseError( "Cannot remove user due to file error." );

		// successfully deleted user
		return true;
    }

	/**
	 * Returns the user's UserID in the password file.
	 * (Glorified line number)
	 * Returns -1 if not found or errors
	 *
	 * @access public
	 */
	function getUserNum( $UserID )
	{
		$count   = 0;
		$usernum = -1;
		$name    = "";

		if ( $this->empty )
			return $usernum;
			
		if ( empty( $UserID ) )
			return $usernum;

		if ( !( $this->isUser( $UserID ) ) )
			return $usernum;

		for ( $count = 0; $count <= $this->usercount; $count++ )
		{
			$name = $this->users[$count]["user"];

			if ( $name != "" )
			{
				if ( $name == $UserID )
				{
					$usernum = $count;
					break;
				}
			}
		}

		return $usernum;
	}

	/**
	 * Generates a pseudo random 2 digit salt. Method will 
	 * generate different salts when called multiple times by
	 * the same process.
	 *
	 * @access public
	 */
	function genSalt()
	{
		$random = 0;
		$rand64 = "";
		$salt   = "";

		$random = rand(); // seeded via initialize()

		// Crypt(3) can only handle A-Z a-z ./
		$rand64 = "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
		$salt   = substr( $rand64, $random % 64, 1 ) . substr( $rand64, ( $random / 64 ) % 64, 1 );
		$salt   = substr( $salt, 0, 2 );

		return ( $salt );
	}

	/**
	 * Generates a pseudo random 5 to 8 digit password. Method will even
	 * generate different passwords when called multiple times by
	 * the same process.
	 *
	 * @access public
	 */
	function genPass()
	{
		$random   = 0;
		$rand78   = "";
		$randpass = "";
		$pass     = "";
		
		$maxcount = rand( 4, 9 );

		// The rand() limits (min 4, max 9) don't actually limit the number
		// returned by rand, so keep looping until we have a password that's
		// more than 4 characters and less than 9.

		if ( ( $maxcount > 8 ) || ( $maxcount < 5 ) )
		{
			do
			{
				$maxcount = rand( 4, 9 );
			} while ( ( $maxcount > 8 ) || ( $maxcount < 5 ) );
		}

		$rand78= "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()-=_+abcdefghijklmnopqrstuvwxyz";
		
		for ( $count = 0; $count <= $maxcount; $count++ )
		{
			$random   = rand( 0, 77 );
			$randpass = substr( $rand78, $random, 1 );
			$pass     = $pass . $randpass;
		}

		$pass = substr( $pass, 0, 8 );
		return( $pass );
	}

	/**
	 * Generates a pseudo random 5 to 8 digit User ID. Method will 
	 * generate different User IDs when called multiple times by
	 * the same process.
	 *
	 * @access public
	 */
	function genUser()
	{
		$random   = 0;
		$rand78   = "";
		$randuser = "";
		$userid   = "";

		$maxcount = rand( 4, 9 );

		if ( ( $maxcount > 8 ) || ( $maxcount < 5 ) )
		{
			do
			{
				$maxcount = rand( 4, 9 );
			} while ( ( $maxcount > 8 ) || ( $maxcount < 5 ) );
		}

		$rand62 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
		
		for ( $count = 0; $count <= $maxcount; $count++ )
		{
			$random   = rand( 0, 61 );
			$randuser = substr( $rand62, $random, 1 );
			$userid   = $userid . $randuser;
		}

		$userid = substr( $userid, 0, 8 );
		return( $userid );
	}
} // END OF HTPasswd

?>
