<!--
Copyright (c) 2000-2002 Microsoft Corp. All rights reserved.
-->



<PROPERTY NAME="movable"/>
<PROPERTY NAME="direction"/>
<PROPERTY NAME="snapable"/>
<PROPERTY NAME="selectable"/>

<METHOD NAME="moveTo"/>
<METHOD NAME="snapToGrid"/>
    
<EVENT NAME="ondrag"      ID="drag"/>
<EVENT NAME="ondragstart" ID="dragstart"/>
<EVENT NAME="ondragend"   ID="dragend"/>
<EVENT NAME="onerror"     ID="error"/>

<ATTACH EVENT="onmouseup"       HANDLER="DoMouseUp"/>
<ATTACH EVENT="onmousedown"     HANDLER="DoMouseDown"/>
<ATTACH EVENT="onclick"         HANDLER="DoSelect"/>
<ATTACH EVENT="onselectstart"   HANDLER="DoSelect"/>
<ATTACH EVENT="ondocumentready" HANDLER="SetDefaults"/>


<script language="JavaScript">

/**
 * On the dragstart event, this variable is set to track the difference between the mouse position and the corner of the element.
 * @access public
 */
var iOffsetX;

/**
 * Same as iOffsetX, but for Y coordinate.
 * @access public
 */
var iOffsetY;

/**
 * Tracks the regular zIndex so it can be restored once the dragend event occurs.
 * @access public
 */
var normZindex = style.zIndex;

/**
 * Used for parsing the mvBoundary prop into it's four component parts.
 * @access public
 */
var zBound = new Array( 
	'Top', 
	'Right', 
	'Bottom', 
	'Left' 
);


/**
 * @access public
 */
function SetDefaults()
{
    // required CSS properties
    style.left     = offsetLeft;
    style.top      = offsetTop;
    style.position = "absolute";

    // Set these properties before the individual ones are set next. Thus, individual properties will override the container properties here.
    style['mvBoundary'] = currentStyle['mv--boundary'];
    style['mvGrid'] = currentStyle['mv--grid'];

    // custom CSS Property Defaults
    CustomDefault( 'mv--boundary-left', 'mvBoundaryLeft', null );
    CustomDefault( 'mv--boundary-right', 'mvBoundaryRight', null );
    CustomDefault( 'mv--boundary-top', 'mvBoundaryTop', null );
    CustomDefault( 'mv--boundary-bottom', 'mvBoundaryBottom', null );
    CustomDefault( 'mv--grid-rows', 'mvGridRows', null );
    CustomDefault( 'mv--grid-cols', 'mvGridCols', null );

    // format the grid and boundary
    FormatGrid();
    FormatBoundary();

    // attach the onpropertychange event
    attachEvent( "onpropertychange", DoPropChange );
};

/**
 * @access public
 */
function CustomDefault( sCSSName, sScriptName, sDefault )
{
    if ( currentStyle[sCSSName] == null )
		style[sCSSName] = sDefault;
    else
		style[sCSSName] = currentStyle[sCSSName];
    
    style[sScriptName] = style[sCSSName];
};

/**
 * @access public
 */
function FormatGrid()
{
    if ( style['mvGrid'] != null )
    {
        if ( style['mvGridCols'] == null )
			style['mvGridCols'] = parseInt( style['mvGrid'].substring( 0, style['mvGrid'].indexOf( " " ) ) );
		
		if ( style['mvGridRows'] == null )
			style['mvGridRows'] = parseInt( style['mvGrid'].substring( style['mvGrid'].indexOf( " " ) + 1, style['mvGrid'].length ) );
    }
    
    // call snapToGrid to enforce new values
    snapToGrid();
};

/**
 * @access public
 */
function FormatBoundary()
{
	if ( style['mvBoundary'] != null )
    {
        var iStart = 0;
        var iEnd   = style['mvBoundary'].indexOf( " " );
                
        for ( var i = 0; i < zBound.length; i++ )
        {
            style['mvBoundary' + zBound[i]] = style['mvBoundary'].substring( iStart, iEnd );
            
			if (iEnd == style['mvBoundary'].length)
				break;
            
            iStart = iEnd + 1;
            iEnd   = style['mvBoundary'].indexOf( " ", iStart );
            
			if ( iEnd == -1 )
				iEnd = style['mvBoundary'].length;
        }
    }

    SetBoundary();
};

/**
 * @access public
 */
function DoPropChange()
{
    var propertyName = window.event.propertyName;

    // Handle CSS property changes by calling necessary functions, setting variables, and/or setting styles
    if ( propertyName.substring( 0, 5 ) == "style" )
    {
        switch ( propertyName )
        {
            case "style.zIndex" :
                normZindex = style.zIndex;
                break;
                
            case "style.position" :
                style.position = "absolute";
                break;
   
            case "style.mvGridRows" :
                snapToGrid();
                break;
                
            case "style.mvGridCols" :
                snapToGrid();
                break;
                
             case "style.mvGrid" :
                FormatGrid();
                break; 
                
            case "style.mvBoundaryLeft" :
                SetBoundary();
                break;

            case "style.mvBoundaryTop" :
                SetBoundary();
                break;
                
            case "style.mvBoundaryRight" :
                SetBoundary();
                break;
                
            case "style.mvBoundaryBottom" :
                SetBoundary();
                break;
                               
            case "style.mvBoundary" :
                FormatBoundary();
                break;
        }
    }
    else
    {
        // Detach the onpropertychange event to prevent it from firing while the changes are handled
        detachEvent( "onpropertychange", DoPropChange );
        
        switch( propertyName )
        {
            case "movable" :
                break;
              
            case "direction" :
                break;
                
            case "snapable" :
                if ( snapable == true || snapable == "true" )
					snapToGrid();
                
				break;
                
            case "selectable" :
                break;

            default :
                ReturnError( propertyName + " not a valid property" );
                break;
        }
        
        // reattach the onpropertychange event
        attachEvent( "onpropertychange", DoPropChange );
    }
};

/**
 * @access public
 */
function moveTo( iNewX, iNewY )
{
    if ( movable == false || movable == "false" )
		return true;

    iNewX = parseInt( iNewX );
    iNewY = parseInt( iNewY );

    if ( isNaN( iNewX ) && isNaN( iNewY ) )
		return false;
    
    // call MoveElement to move the piece
    MoveElement( iNewX, iNewY );
};

/**
 * @access public
 */
function snapToGrid()
{
    // call MoveElement to move the piece
    MoveElement( offsetLeft, offsetTop, true );
};

/**
 * @access public
 */
function SetBoundary()
{
    // obey right boundary
    if ( style.mvBoundaryRight != null && style.mvBoundaryRight < style.posLeft + offsetWidth )
		style.left = style.mvBoundaryRight - offsetWidth;
    
    // obey left boundary
    if ( style.mvBoundaryLeft && style.mvBoundaryLeft > style.posLeft )
		style.left = style.mvBoundaryLeft;
    
    // obey bottom boundary
    if ( style.mvBoundaryBottom && style.mvBoundaryBottom < style.posTop + offsetHeight )
		style.top = style.mvBoundaryBottom - offsetHeight;
    
    // obey top boundary
    if ( style.mvBoundaryTop && style.mvBoundaryTop > style.posTop )
		style.top = style.mvBoundaryTop;
    
    // If the element is snapable, call snapToGrid to snap it.
    if ( snapable == true || snapable == "true" )
		snapToGrid();
};

/**
 * @access public
 */
function MoveElement( iNewX, iNewY, bSnapTo )
{
    if ( ( direction != "vertical" ) && ( iNewX != null ) )
    {
        // If the piece is snapable, then both the grid and the boundary (if one exists) have to be enforced.
        if ( ( snapable == true || snapable == "true" || bSnapTo == true ) && style.mvGridCols != null )
        {
            // find the closest grid
            var iSnapX = ( Math.round( iNewX / style.mvGridCols ) ) * style.mvGridCols;

            // if the piece is outside of the boundaries, put on a grid inside
            if ( ( style.mvBoundaryLeft != null ) && ( iSnapX < style.mvBoundaryLeft ) )
				iSnapX = ( Math.ceil( style.mvBoundaryLeft / style.mvGridCols ) ) * style.mvGridCols;
            else if ( ( style.mvBoundaryRight != null ) && ( iSnapX > style.mvBoundaryRight - offsetWidth ) )
				iSnapX = ( Math.floor( ( style.mvBoundaryRight - offsetWidth ) / style.mvGridCols ) ) * style.mvGridCols;

            iNewX = iSnapX;
        }
        // Otherwise, if the piece has just a boundary, then it needs to be enforced.  If the piece is outside the boundaries, put it inside.
        else if ( ( style.mvBoundaryLeft != null ) && ( iNewX < style.mvBoundaryLeft ) )
        {
            iNewX = style.mvBoundaryLeft;
        }
        else if ( ( style.mvBoundaryRight != null ) && ( iNewX > style.mvBoundaryRight - offsetWidth ) )
        {
            iNewX = style.mvBoundaryRight - offsetWidth;
        }

        // put the piece in it's (possibly adjusted) position
        style.left = iNewX;
    }

    if ( ( direction != "horizontal" ) && ( iNewY != null ) )
    {
        // If the piece is snapable, then both the grid and the boundary (if one exists) have to be enforced.
        if ( ( snapable == true || snapable == "true" || bSnapTo == true ) && style.mvGridRows != null )
        {
            //  find the closest grid
            var iSnapY = ( Math.round( iNewY / style.mvGridRows ) ) * style.mvGridRows;

            // if the piece is outside of the boundaries, put on a grid inside
            if ( ( style.mvBoundaryTop != null ) && ( iSnapY < style.mvBoundaryTop ) )
				iSnapY = ( Math.ceil( style.mvBoundaryTop / style.mvGridRows ) ) * style.mvGridRows;
            else if ( ( style.mvBoundaryBottom != null ) && ( iSnapY > style.mvBoundaryBottom - offsetHeight ) )
				iSnapY = ( Math.floor( ( style.mvBoundaryBottom - offsetHeight ) / style.mvGridRows ) ) * style.mvGridRows;
            
            iNewY = iSnapY;
        }
        // Otherwise, if the piece has just a boundary, then it needs to be enforced.  If the piece is outside the boundaries, put it inside.
        else if ( ( style.mvBoundaryTop != null ) && ( iNewY < style.mvBoundaryTop ) )
        {
        	iNewY = style.mvBoundaryTop;
        }
        else if ( ( style.mvBoundaryBottom != null ) && ( iNewY > style.mvBoundaryBottom - offsetHeight ) )
        {
            iNewY = style.mvBoundaryBottom - offsetHeight;
        }
    
        // put the piece in it's (possibly adjusted) position
        style.top = iNewY;
    }
};

/**
 * @access public
 */
function DoMouseDown()
{
    // if the piece is not movable, don't allow it to be moved
    if ( movable == false || movable == "false" )
		return true;
            
    // capture the mouse
    setCapture();
    
    // set the zIndex to 1000 to put it over other elements while it's moved
	style.zIndex = 1000;

    // Determine the difference between the mouse click on the element and the top left corner.
	iOffsetX = window.event.x - element.style.pixelLeft;
	iOffsetY = window.event.y - element.style.pixelTop;

    // start tracking the mousemove
	attachEvent( "onmousemove", DoMouseMove );
	dragstart.fire();
};

/**
 * @access public
 */
function DoMouseMove()
{
	if ( direction != "vertical" ) 
	{
	    // set position based on mouse movement
	    var iNewX = window.event.x - iOffsetX;
    
        // obey left boundary
	    if ( ( style.mvBoundaryLeft != null ) && ( iNewX < style.mvBoundaryLeft ) )
			iNewX = style.mvBoundaryLeft;
	    
	    // obey right boundary
	    if ( ( style.mvBoundaryRight != null ) && ( iNewX > style.mvBoundaryRight - offsetWidth ) )
			iNewX = style.mvBoundaryRight - offsetWidth;

        // place element
	    style.left = iNewX;
	}

	if ( direction != "horizontal" )
	{
	    // set position based on mouse movement
	    var iNewY = window.event.y - iOffsetY;
	    
	    // obey top boundary
	    if ( ( style.mvBoundaryTop != null ) && ( iNewY < style.mvBoundaryTop ) )
			iNewY = style.mvBoundaryTop;
	    
	    // obey bottom boundary
	    if ( ( style.mvBoundaryBottom != null ) && ( iNewY > style.mvBoundaryBottom - offsetHeight ) )
			iNewY = style.mvBoundaryBottom - offsetHeight;
	    
	    // place element
	    style.top = iNewY;
	}
	
	drag.fire();
};

/**
 * @access public
 */
function DoMouseUp()
{
    // return the zIndex to its previous value
	style.zIndex = normZindex;

    // stop tracking the onmousemove event
	detachEvent( "onmousemove", DoMouseMove );
	
	// release the mouse
	releaseCapture();

    // if it's snapable, snap it now
	if ( snapable == "true" || snapable == true )
		snapToGrid();

    window.event.srcElement.click();
	dragend.fire();
};

/**
 * @access public
 */
function DoSelect()
{
    if ( selectable != "true" && selectable != true )
		window.event.returnValue = false;
};

/**
 * @access public
 */
function ReturnError( sMsg )
{
    var oEvent = createEventObject();
	
    oEvent.setAttribute( "error", sMsg );
    error.fire( oEvent );
};

</script>
